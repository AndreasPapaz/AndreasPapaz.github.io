<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://andreaspapaz.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://andreaspapaz.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-20T21:47:37+00:00</updated><id>https://andreaspapaz.github.io/feed.xml</id><title type="html">The Wonderful World of Java</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Java Pass by Reference vs Pass by Value</title><link href="https://andreaspapaz.github.io/blog/2025/JavaReference/" rel="alternate" type="text/html" title="Java Pass by Reference vs Pass by Value"/><published>2025-12-12T14:24:00+00:00</published><updated>2025-12-12T14:24:00+00:00</updated><id>https://andreaspapaz.github.io/blog/2025/JavaReference</id><content type="html" xml:base="https://andreaspapaz.github.io/blog/2025/JavaReference/"><![CDATA[<h1 id="java-pass-by-reference-or-pass-by-value">Java Pass by Reference or Pass by Value</h1> <p>I’m going over C++ as a refresh to prepare for my upcoming semester taking an official course on <strong>Computer Architecture &amp; Assembly Lang</strong>, even though it’s going to be just a touch of C and probably no C++. Nonetheless, it’s something that I think every Software Engineer and Student of Computer Science should get very comfortable with.</p> <p>C/C++ are, in my opinion, the cornerstone of modern software engineering programming languages. Take a look at <code class="language-plaintext highlighter-rouge">Go</code>, trying to compete by having <code class="language-plaintext highlighter-rouge">goroutines</code> and being a <strong>compiled</strong> language. Or <code class="language-plaintext highlighter-rouge">Rust</code>, the <em>Memory</em> safe and <em>Concurrency</em> secure language of choice. But at the end, companies from Jane Street, Citadel to Boring Company, and Google are looking for competent C/C++ developers. In part, learning C++ will help with understanding why it’s so fun to use something like <code class="language-plaintext highlighter-rouge">Python</code></p> <blockquote> <p>“If I have seen further, it is by standing on the shoulders of giants”</p> <ul> <li>Sir Isaac Newton in a 1675 letter, referring to his scientific breakthroughs</li> </ul> </blockquote> <p>So a great question I ask during interviews and when I join lunch with my team is, “Is Java Pass by Reference or Pass by Value?”. The younger Junior devs are the ones I’m interested in learning from to keep up with the times in what they are interested in. Talk to an old head who had to use <code class="language-plaintext highlighter-rouge">COBOL</code> and that’s when the discussion gets spicy with side-tracked topics of different compilers, paradigms, etc.</p> <h3 id="pass-by-reference">Pass by Reference</h3> <p>So, what is pass by reference?</p> <p>Let’s use C++. We can have pointers to a variable</p> <pre><code class="language-C++">int x = 4; // create an int (4 bytes) and assign it to the value 4
int *xP = &amp;x; // create a pointer of type int (4 bytes) and assign it to reference, x
</code></pre> <p>Doing a <code class="language-plaintext highlighter-rouge">std::cout &lt;&lt; xP &lt;&lt; endl;</code> would yield me something like <code class="language-plaintext highlighter-rouge">0x7fffdc4b0a2c</code>, which is an address in the stack. If I <code class="language-plaintext highlighter-rouge">dereference</code> the pointer by <code class="language-plaintext highlighter-rouge">*xP</code>, then I can get the assigned value of <code class="language-plaintext highlighter-rouge">4</code>;</p> <p>Ok, it’s a bit much if we are looking at this for the first time. Let’s digest this diagram before continuing.</p> <p>+——————————-+ +——————————-+ | Stack | | Heap | | (grows downward) | | (grows upward) | +——————————-+ +——————————-+ | int a = 10; | address: 0x1000 | <br/> | int b = 20; | address: 0x1004 | <br/> | int c = 30; | address: 0x1008 | <br/> | | | | | int* ptr; | address: 0x1010 | +——————————-+ | ptr → 0x2000 —————————&gt; | int thisNum = 100; | addr: 0x2000 | | | | | +——————————-+ +——————————-+</p> <p>Later: ptr = new int(100); // allocation on heap *ptr == 100 // dereferencing gives the Value</p> <p>We can see that <code class="language-plaintext highlighter-rouge">*ptr</code> is initialized at address <code class="language-plaintext highlighter-rouge">0x1010</code> then later it’s assigned the same address as <code class="language-plaintext highlighter-rouge">int thisNum</code> at address <code class="language-plaintext highlighter-rouge">0x2000</code> We have <code class="language-plaintext highlighter-rouge">ptr</code> and <code class="language-plaintext highlighter-rouge">thisNum</code> both pointing to the same address in memory.</p> <p>Let’s take this example for C++ passing by reference.</p> <pre><code class="language-C++">void incrementByReference(int&amp; x) // Note the &amp; indicates that this is a reference/pointer to memory address
{
    x++;                    
}

int main()
{
    int a = 10;
    
    incrementByReference(a); // --&gt; this will change the value to 11
    std::cout &lt;&lt; "After passing by Reference :: " &lt;&lt; a &lt;&lt; endl;

    return 0;
}
</code></pre> <p>So, we can see that we manipulated the value of <code class="language-plaintext highlighter-rouge">a</code> and changed it in another method. <code class="language-plaintext highlighter-rouge">&amp;x</code> means that it’s pointing to the same address as <code class="language-plaintext highlighter-rouge">a</code>. This will go to that address, and increment its value by 1.</p> <p>Let’s look at passing by value now</p> <pre><code class="language-C++">void incrementByValue(int x) // Creates a local copy
{
    x++;
}

int main() 
{
    int y = 200;

    incrementByValue(y); // value y, in the main() scope remains 200.
    
    std::cout &lt;&lt; "After passing by Value :: " &lt;&lt; y &lt;&lt; endl;

    return 0;
}
</code></pre> <p>In this example, we take the <code class="language-plaintext highlighter-rouge">y</code> and pass it in the method <code class="language-plaintext highlighter-rouge">incrementByValue</code> which then makes a local variable for its own function scope to use. After this scope is returned we lose reference to that copy as it goes out of scope.</p> <h2 id="what-java-does-that-cc-doesnt">What Java does that C/C++ doesn’t</h2> <p>In Java we write methods/functions like …</p> <pre><code class="language-Java">public static void myMethod(int x) {
    x++;
}
</code></pre> <p>Java simply does not allow pass by reference, we always pass by value. Thus, we say, Java is pass by value.</p> <p>Whenever we pass primitives we expect this behavior. Now take a look at this example.</p> <pre><code class="language-Java">class Car {
    public boolean isElectric;
}

public void electrifyCar(Car car) {
    car.isElectric = true;
}

public static void main(String[] args) { 
    Car myCar = new Car();
    myCar.isElectric = false;
    System.out.println(myCar.isElectric); // false, we set it above
    
    electrifyCar(myCar);
    System.out.println(myCar.isElectric); // what would the value here be?
}
</code></pre> <p>After we call our <code class="language-plaintext highlighter-rouge">electrifyCar()</code> method, what is the value and why?</p> <hr/> <p>The value of <code class="language-plaintext highlighter-rouge">isElectric</code> is now <code class="language-plaintext highlighter-rouge">true</code>. But why? Java is a pass by value language. Although, the rule is we always pass by value when it’s a primitive value such as <code class="language-plaintext highlighter-rouge">String</code> or <code class="language-plaintext highlighter-rouge">int</code>/<code class="language-plaintext highlighter-rouge">Integer</code>. But when it comes to <code class="language-plaintext highlighter-rouge">Objects</code> we pass by value, where the value is the memory address.</p> <p>This is a tidbit that almost everyone gets confused with but you will see Java Software Engineers use without ever really thinking about why that’s the case and what the Java JVM &amp; Compiler is doing.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="charts"/><summary type="html"><![CDATA[Coming soon]]></summary></entry></feed>